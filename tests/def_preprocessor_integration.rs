// SPDX-License-Identifier: MIT
// SPDX-FileCopyrightText: 2025 Huang Rui <vowstar@gmail.com>

//! Integration tests for DEF preprocessor with parser

use lefdef_viewer::def::parser::component::DefComponentParser;
use lefdef_viewer::def::parser::MultiLineParser;
use lefdef_viewer::def::preprocessor::preprocess;

#[test]
fn test_single_line_component_format() {
    let input = r#"COMPONENTS 3 ;
- C1 M1 + FIXED ( 100 200 ) N ;
- C2 M2 + PLACED ( 300 400 ) S ;
- C3 M3 + SOURCE DIST + FIXED ( 500 600 ) E ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);
    let parser = MultiLineParser::with_preprocessed(DefComponentParser);

    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 3);

    assert_eq!(components[0].name, "C1");
    assert_eq!(components[0].macro_name, "M1");
    let p1 = components[0].placement.as_ref().unwrap();
    assert_eq!(p1.placement_type, "FIXED");
    assert_eq!(p1.x, 100.0);
    assert_eq!(p1.y, 200.0);
    assert_eq!(p1.orientation, "N");

    assert_eq!(components[1].name, "C2");
    let p2 = components[1].placement.as_ref().unwrap();
    assert_eq!(p2.placement_type, "PLACED");

    assert_eq!(components[2].name, "C3");
    assert_eq!(components[2].source, Some("DIST".to_string()));
}

#[test]
fn test_two_line_component_format() {
    let input = r#"COMPONENTS 2 ;
- C1 M1 + FIXED ( 100 200 ) N
 ;
- C2 M2 + PLACED ( 300 400 ) S
 ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);
    let parser = MultiLineParser::with_preprocessed(DefComponentParser);

    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 2);

    assert_eq!(components[0].name, "C1");
    let p1 = components[0].placement.as_ref().unwrap();
    assert_eq!(p1.placement_type, "FIXED");
    assert_eq!(p1.x, 100.0);
    assert_eq!(p1.y, 200.0);
    assert_eq!(p1.orientation, "N");

    assert_eq!(components[1].name, "C2");
    let p2 = components[1].placement.as_ref().unwrap();
    assert_eq!(p2.placement_type, "PLACED");
    assert_eq!(p2.x, 300.0);
    assert_eq!(p2.y, 400.0);
}

#[test]
fn test_multi_line_component_format() {
    let input = r#"COMPONENTS 1 ;
- C1 M1
 + FIXED ( 100 200 ) N
 + SOURCE DIST
 ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);
    let parser = MultiLineParser::with_preprocessed(DefComponentParser);

    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 1);

    assert_eq!(components[0].name, "C1");
    assert_eq!(components[0].macro_name, "M1");
    let p = components[0].placement.as_ref().unwrap();
    assert_eq!(p.placement_type, "FIXED");
    assert_eq!(p.x, 100.0);
    assert_eq!(p.y, 200.0);
    assert_eq!(components[0].source, Some("DIST".to_string()));
}

#[test]
fn test_fusion_compiler_format() {
    let input = r#"# Fusion Compiler write_def
VERSION 5.8 ;
DESIGN test_design ;
COMPONENTS 3 ;
- u_io_top/comp1 MACRO1 + FIXED ( 0 100 ) N
 ;
- u_io_top/comp2 MACRO2 + PLACED ( 200 300 ) S
 ;
- comp3 MACRO3 + FIXED ( 400 500 ) E ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);

    // Find COMPONENTS line
    let comp_idx = preprocessed
        .lines
        .iter()
        .position(|l| l.trim().starts_with("COMPONENTS"))
        .unwrap();

    let parser = MultiLineParser::with_preprocessed(DefComponentParser);
    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, comp_idx + 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 3);

    assert_eq!(components[0].name, "u_io_top/comp1");
    assert_eq!(components[1].name, "u_io_top/comp2");
    assert_eq!(components[2].name, "comp3");

    // Check placements
    assert!(components[0].placement.is_some());
    assert!(components[1].placement.is_some());
    assert!(components[2].placement.is_some());
}

#[test]
fn test_cadence_innovus_format() {
    let input = r#"###############################################################
#  Generated by:      Cadence Innovus 22.33-s094_1
#  OS:                Linux x86_64(Host ID owl-s1)
#  Generated on:      Thu Nov 27 20:26:58 2025
#  Design:            soc_top
#  Command:           defOut -selected io.def
###############################################################
VERSION 5.8 ;
DIVIDERCHAR "/" ;
BUSBITCHARS "[]" ;
DESIGN soc_top ;
UNITS DISTANCE MICRONS 1000 ;

COMPONENTS 2 ;
- u_io_top/u_TEST_west_9 HPDWUW0608DGP_H + FIXED ( 0 4735000 ) E
 ;
- u_io_top/u_RST_N_west_11 HPDWUW0608DGP_H + FIXED ( 0 4655000 ) E
 ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);

    // Find COMPONENTS line
    let comp_idx = preprocessed
        .lines
        .iter()
        .position(|l| l.trim().starts_with("COMPONENTS"))
        .unwrap();

    let parser = MultiLineParser::with_preprocessed(DefComponentParser);
    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, comp_idx + 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 2);

    assert_eq!(components[0].name, "u_io_top/u_TEST_west_9");
    assert_eq!(components[0].macro_name, "HPDWUW0608DGP_H");
    let p1 = components[0].placement.as_ref().unwrap();
    assert_eq!(p1.placement_type, "FIXED");
    assert_eq!(p1.x, 0.0);
    assert_eq!(p1.y, 4735000.0);
    assert_eq!(p1.orientation, "E");

    assert_eq!(components[1].name, "u_io_top/u_RST_N_west_11");
    assert_eq!(components[1].macro_name, "HPDWUW0608DGP_H");
    let p2 = components[1].placement.as_ref().unwrap();
    assert_eq!(p2.placement_type, "FIXED");
    assert_eq!(p2.x, 0.0);
    assert_eq!(p2.y, 4655000.0);
    assert_eq!(p2.orientation, "E");
}

#[test]
fn test_mixed_single_and_multi_line() {
    let input = r#"COMPONENTS 4 ;
- C1 M1 + FIXED ( 100 200 ) N ;
- C2 M2 + PLACED ( 300 400 ) S
 ;
- C3 M3
 + FIXED ( 500 600 ) E
 ;
- C4 M4 + SOURCE DIST + FIXED ( 700 800 ) W ;
END COMPONENTS
"#;

    let preprocessed = preprocess(input);
    let parser = MultiLineParser::with_preprocessed(DefComponentParser);

    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 4);

    // All components should have proper placements
    assert!(components[0].placement.is_some());
    assert!(components[1].placement.is_some());
    assert!(components[2].placement.is_some());
    assert!(components[3].placement.is_some());
}

#[test]
fn test_with_comments_inline() {
    let input = r#"COMPONENTS 2 ; # Component section starts here
- C1 M1 + FIXED ( 100 200 ) N ; # First component
- C2 M2 + PLACED ( 300 400 ) S ; # Second component
END COMPONENTS # Section ends
"#;

    let preprocessed = preprocess(input);
    let parser = MultiLineParser::with_preprocessed(DefComponentParser);

    let (components, _) = parser
        .parse_section_preprocessed(&preprocessed.lines, 1, "END COMPONENTS")
        .expect("Failed to parse components");

    assert_eq!(components.len(), 2);

    // Comments should be removed, parsing should work
    assert_eq!(components[0].name, "C1");
    assert_eq!(components[1].name, "C2");
}
